# 前端进阶

## 前端工程化

### cjs/esm

- cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用
- cjs 模块是运行时加载，esm 是编译时加载

### AST

抽象语法树

- parse：把代码解析为AST。
- transform：对AST中的各个节点做相关操作，如新增、删除、替换、追加。业务开发 95%的代码都在这里。
- generator：把AST转换为代码。

### 运行时

- webpack
  
  `webpack` 的 runtime，也就是 webpack 最后生成的代码，做了以下三件事:
  
  1. `__webpack_modules__`: 维护一个所有模块的数组。将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数 `(module, module.exports, __webpack_require__)` 对模块进行包裹构成。
  2. `__webpack_require__(moduleId)`: 手动实现加载一个模块。对已加载过的模块进行缓存，对未加载过的模块，执行 id 定位到 `__webpack_modules__` 中的包裹函数，执行并返回 `module.exports`，并缓存
  3. `__webpack_require__(0)`: 运行第一个模块，即运行入口模块

- rollup：esModule打包器
  
  将项目中散落的小模块打包成整块的代码，让划分的小模块可以更好地运行在浏览器环境和nodejs环境
  
  **作用：** 与webpack非常类似
  
  **对比：** Rollup相对于webpack更小巧，webpack可以完成项目中各种工程化的需求，而Rollup仅仅是一款ESM（ESmodule）打包器，没有任何其它的功能。 例如，webpack中有HMR（热替换功能），Rollup中没有
  
  **Rollup的意义：** 提供一个充分利用ESM各项特性的高效打包器。利用ESmodule的各种特性构建出结构比较扁平，性能比较出众的类库。

### 加载样式

1. [css-loader (opens new window)](https://github.com/webpack-contrib/css-loader): 处理 CSS 中的 `url` 与 `@import`，并将其视为模块引入，此处是通过 postcss 来解析处理，postcss 对于工程化中 css 处理的影响力可见一斑。
2. [style-loader (opens new window)](https://github.com/webpack-contrib/style-loader): 将样式注入到 DOM 中

### HMR热更新

1. `webpack-dev-server` 将打包输出 bundle 使用内存型文件系统控制，而非真实的文件系统。此时使用的是 [memfs (opens new window)](https://github.com/streamich/memfs)模拟 node.js `fs` API
2. 每当文件发生变更时，`webpack` 将会重新编译，`webpack-dev-server` 将会监控到此时文件变更事件，并找到其对应的 `module`。此时使用的是 [chokidar (opens new window)](https://github.com/paulmillr/chokidar)监控文件变更
3. `webpack-dev-server` 将会把变更模块通知到浏览器端，此时使用 `websocket` 与浏览器进行交流。此时使用的是 [ws(opens new window)](https://github.com/websockets/ws)
4. 浏览器根据 `websocket` 接收到 hash，并通过 hash 以 JSONP 的方式请求更新模块的 chunk
5. 浏览器加载 chunk，并使用新的模块对旧模块进行热替换，并删除其缓存

### treeshaking

指基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。

- 编译阶段利用`ES6 Module`判断哪些模块已经加载
- 判断那些模块和变量未被使用或者引用，进而删除对应代码

### poltfill:core.js

[core-js (opens new window)](https://github.com/zloirock/core-js)是关于 ES 标准最出名的 `polyfill`，polyfill 意指当浏览器不支持某一最新 API 时，它将帮你实现，中文叫做垫片。你也许每天都与它打交道，但你毫不知情。

由于垫片的存在，打包后体积便会增加，所需支持的浏览器版本越高，垫片越少，体积就会越小。

**而 `core-js` 的伟大之处是它包含了所有 `ES6+` 的 polyfill，并集成在 `babel` 等编译工具之中。**

已经集成到`babel`/`swc`中了

## 前端性能优化

### 时间角度：减少耗时

1. **网络请求优化。**
   
   请求链路：DNS 缓存、部署 CDN 节点、HTTP缓存、请求合并减少通信次数、提升并发请求数量
   
   数据大小：代码大小、图片资源合理拆分和压缩、开启gzip等。

2. **首屏加载优化。**
   
   整体的优化思路包括：尽可能提前页面可见，以及将用户可交互的时间提前。一般来说，我们需要尽可能地降低首屏需要的代码量和执行耗时，可以通过以下方式进行：
   
   - 对页面的内容进行分片/分屏加载
   - 仅加载需要的资源，通过异步或是懒加载的方式加载剩余资源
   - 使用骨架屏进行预渲染
   - 使用服务端直出渲染，减少页面二次请求和渲染的耗时

3. 渲染过程（二次渲染）优化。
   
   主要思路是减少用户的操作等待时间，以及通过将页面渲染帧率保持在 60FPS 左右，提升页面交互和渲染的流畅度。包括但不限于以下方案：
   
   - 使用资源预加载，提升空闲时间的资源利用率
   - 减少/合并 DOM 操作，减少浏览器渲染过程中的计算耗时

4. 计算/逻辑运行提速。
   
   计算/逻辑运行速度优化的主要思路是“拆大为小、多路并行”，方式包括但不限于：
   
   - 通过将 Javscript 大任务进行拆解，结合异步任务的管理，避免出现长时间计算导致页面卡顿的情况
   - 将耗时长且非关键逻辑的计算拆离，比如使用 Web Worker
   - 通过使用更优的算法或是存储结构，提升计算效率，比如 VSCode 使用红黑树优化文本缓冲区的计算
   - 通过将计算结果缓存的方式，减少运算次数

### 空间角度：降低资源占用

资源占用常见的优化方式包括：

- 合理使用缓存，不滥用用户的缓存资源（比如浏览器缓存、IndexDB），及时进行缓存清理
- 避免存在内存泄露，比如尽量避免全局变量的使用、及时解除引用等
- 避免复杂/异常的递归调用，导致调用栈的溢出
