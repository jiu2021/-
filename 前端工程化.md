# 前端工程化

### cjs/esm

- cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用
- cjs 模块是运行时加载，esm 是编译时加载

### AST

抽象语法树

- parse：把代码解析为AST。
- transform：对AST中的各个节点做相关操作，如新增、删除、替换、追加。业务开发 95%的代码都在这里。
- generator：把AST转换为代码。

### 运行时

- webpack
  
  `webpack` 的 runtime，也就是 webpack 最后生成的代码，做了以下三件事:
  
  1. `__webpack_modules__`: 维护一个所有模块的数组。将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数 `(module, module.exports, __webpack_require__)` 对模块进行包裹构成。
  2. `__webpack_require__(moduleId)`: 手动实现加载一个模块。对已加载过的模块进行缓存，对未加载过的模块，执行 id 定位到 `__webpack_modules__` 中的包裹函数，执行并返回 `module.exports`，并缓存
  3. `__webpack_require__(0)`: 运行第一个模块，即运行入口模块

- rollup：esModule打包器
  
  将项目中散落的小模块打包成整块的代码，让划分的小模块可以更好地运行在浏览器环境和nodejs环境
  
  **作用：** 与webpack非常类似
  
  **对比：** Rollup相对于webpack更小巧，webpack可以完成项目中各种工程化的需求，而Rollup仅仅是一款ESM（ESmodule）打包器，没有任何其它的功能。 例如，webpack中有HMR（热替换功能），Rollup中没有
  
  **Rollup的意义：** 提供一个充分利用ESM各项特性的高效打包器。利用ESmodule的各种特性构建出结构比较扁平，性能比较出众的类库。

### 加载样式

1. [css-loader (opens new window)](https://github.com/webpack-contrib/css-loader): 处理 CSS 中的 `url` 与 `@import`，并将其视为模块引入，此处是通过 postcss 来解析处理，postcss 对于工程化中 css 处理的影响力可见一斑。
2. [style-loader (opens new window)](https://github.com/webpack-contrib/style-loader): 将样式注入到 DOM 中

### HMR热更新

1. `webpack-dev-server` 将打包输出 bundle 使用内存型文件系统控制，而非真实的文件系统。此时使用的是 [memfs (opens new window)](https://github.com/streamich/memfs)模拟 node.js `fs` API
2. 每当文件发生变更时，`webpack` 将会重新编译，`webpack-dev-server` 将会监控到此时文件变更事件，并找到其对应的 `module`。此时使用的是 [chokidar (opens new window)](https://github.com/paulmillr/chokidar)监控文件变更
3. `webpack-dev-server` 将会把变更模块通知到浏览器端，此时使用 `websocket` 与浏览器进行交流。此时使用的是 [ws(opens new window)](https://github.com/websockets/ws)
4. 浏览器根据 `websocket` 接收到 hash，并通过 hash 以 JSONP 的方式请求更新模块的 chunk
5. 浏览器加载 chunk，并使用新的模块对旧模块进行热替换，并删除其缓存

### treeshaking

指基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。

- 编译阶段利用`ES6 Module`判断哪些模块已经加载
- 判断那些模块和变量未被使用或者引用，进而删除对应代码

### poltfill:core.js

[core-js (opens new window)](https://github.com/zloirock/core-js)是关于 ES 标准最出名的 `polyfill`，polyfill 意指当浏览器不支持某一最新 API 时，它将帮你实现，中文叫做垫片。你也许每天都与它打交道，但你毫不知情。

由于垫片的存在，打包后体积便会增加，所需支持的浏览器版本 ​ 越高，垫片越少，体积就会越小。

**而 `core-js` 的伟大之处是它包含了所有 `ES6+` 的 polyfill，并集成在 `babel` 等编译工具之中。**

已经集成到`babel`/`swc`中了
