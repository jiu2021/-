# 前端进阶

## 模块化

- 避免命名冲突(减少命名空间污染)
- 更好的分离, 按需加载
- 更高复用性
- 高可维护性

### CommonJs

**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包（Browserify）处理。**

- 所有代码都运行在模块作用域，不会污染全局作用域。
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
- 模块加载的顺序，按照其在代码中出现的顺序。

**加载机制：** 输出值拷贝

### AMD（Asynchronous Module Definition）

异步模块加载机制

**AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系**。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。

### CMD（Common Module Definition）

CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。

### ESM

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。

**与cjs相比：** 

- cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用
  
  ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

- cjs 模块是运行时加载，esm 是编译时加载
  
  因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

**使用Babel将ES6编译为ES5代码，使用Browserify编译打包js**。

### 总结

- CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。
- AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。
- CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重
- **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。

## treeshaking

### dead code

Dead Code 一般具有以下几个特征

- 代码不会被执行，不可到达

- 代码执行的结果不会被用到

- 代码只会影响死变量（只写不读）

是由代码压缩优化工具**uglify**做的

### treeshaking

依赖ES6M的静态分析

对函数效果较好，不能移除无用类（rollup，webpack）

三大工具的tree-shaking对于无用代码，无用模块的消除，都是有限的，有条件的。closure compiler是最好的，但与我们日常的基于node的开发流很难兼容。

## webpack

### AST

抽象语法树

- parse：把代码解析为AST。
- transform：对AST中的各个节点做相关操作，如新增、删除、替换、追加。业务开发 95%的代码都在这里。
- generator：把AST转换为代码。

### 运行时

- webpack
  
  `webpack` 的 runtime，也就是 webpack 最后生成的代码，做了以下三件事:
  
  1. `__webpack_modules__`: 维护一个所有模块的数组。将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数 `(module, module.exports, __webpack_require__)` 对模块进行包裹构成。
  2. `__webpack_require__(moduleId)`: 手动实现加载一个模块。对已加载过的模块进行缓存，对未加载过的模块，执行 id 定位到 `__webpack_modules__` 中的包裹函数，执行并返回 `module.exports`，并缓存
  3. `__webpack_require__(0)`: 运行第一个模块，即运行入口模块

- rollup：esModule打包器
  
  将项目中散落的小模块打包成整块的代码，让划分的小模块可以更好地运行在浏览器环境和nodejs环境
  
  **作用：** 与webpack非常类似
  
  **对比：** Rollup相对于webpack更小巧，webpack可以完成项目中各种工程化的需求，而Rollup仅仅是一款ESM（ESmodule）打包器，没有任何其它的功能。 例如，webpack中有HMR（热替换功能），Rollup中没有
  
  **Rollup的意义：** 提供一个充分利用ESM各项特性的高效打包器。利用ESmodule的各种特性构建出结构比较扁平，性能比较出众的类库。

### 加载样式

1. [css-loader (opens new window)](https://github.com/webpack-contrib/css-loader): 处理 CSS 中的 `url` 与 `@import`，并将其视为模块引入，此处是通过 postcss 来解析处理，postcss 对于工程化中 css 处理的影响力可见一斑。
2. [style-loader (opens new window)](https://github.com/webpack-contrib/style-loader): 将样式注入到 DOM 中

### HMR热更新

1. `webpack-dev-server` 将打包输出 bundle 使用内存型文件系统控制，而非真实的文件系统。此时使用的是 [memfs (opens new window)](https://github.com/streamich/memfs)模拟 node.js `fs` API
2. 每当文件发生变更时，`webpack` 将会重新编译，`webpack-dev-server` 将会监控到此时文件变更事件，并找到其对应的 `module`。此时使用的是 [chokidar (opens new window)](https://github.com/paulmillr/chokidar)监控文件变更
3. `webpack-dev-server` 将会把变更模块通知到浏览器端，此时使用 `websocket` 与浏览器进行交流。此时使用的是 [ws(opens new window)](https://github.com/websockets/ws)
4. 浏览器根据 `websocket` 接收到 hash，并通过 hash 以 JSONP 的方式请求更新模块的 chunk
5. 浏览器加载 chunk，并使用新的模块对旧模块进行热替换，并删除其缓存

### treeshaking

指基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。

- 编译阶段利用`ES6 Module`判断哪些模块已经加载
- 判断那些模块和变量未被使用或者引用，进而删除对应代码

### poltfill:core.js

[core-js (opens new window)](https://github.com/zloirock/core-js)是关于 ES 标准最出名的 `polyfill`，polyfill 意指当浏览器不支持某一最新 API 时，它将帮你实现，中文叫做垫片。你也许每天都与它打交道，但你毫不知情。

由于垫片的存在，打包后体积便会增加，所需支持的浏览器版本越高，垫片越少，体积就会越小。

**而 `core-js` 的伟大之处是它包含了所有 `ES6+` 的 polyfill，并集成在 `babel` 等编译工具之中。**

已经集成到`babel`/`swc`中了

## 前端性能优化

### 时间角度：减少耗时

1. **网络请求优化。**
   
   请求链路：DNS 缓存、部署 CDN 节点、HTTP缓存、请求合并减少通信次数、提升并发请求数量
   
   数据大小：代码大小（treeshaking、peerdependency）、图片资源合理拆分和压缩、开启gzip等。

2. **首屏加载优化。**
   
   整体的优化思路包括：尽可能提前页面可见，以及将用户可交互的时间提前。一般来说，我们需要尽可能地降低首屏需要的代码量和执行耗时，可以通过以下方式进行：
   
   - 对页面的内容进行分片/分屏加载
   - 仅加载需要的资源，通过异步或是懒加载的方式加载剩余资源
   - 使用骨架屏进行预渲染
   - 使用服务端直出渲染，减少页面二次请求和渲染的耗时

3. 渲染过程（二次渲染）优化。
   
   主要思路是减少用户的操作等待时间，以及通过将页面渲染帧率保持在 60FPS 左右，提升页面交互和渲染的流畅度。包括但不限于以下方案：
   
   - 使用资源预加载，提升空闲时间的资源利用率
   - 减少/合并 DOM 操作，减少浏览器渲染过程中的计算耗时

4. 计算/逻辑运行提速。
   
   计算/逻辑运行速度优化的主要思路是“拆大为小、多路并行”，方式包括但不限于：
   
   - 通过将 Javscript 大任务进行拆解，结合异步任务的管理，避免出现长时间计算导致页面卡顿的情况
   - 将耗时长且非关键逻辑的计算拆离，比如使用 Web Worker
   - 通过使用更优的算法或是存储结构，提升计算效率，比如 VSCode 使用红黑树优化文本缓冲区的计算
   - 通过将计算结果缓存的方式，减少运算次数

### 空间角度：降低资源占用

资源占用常见的优化方式包括：

- 合理使用缓存，不滥用用户的缓存资源（比如浏览器缓存、IndexDB），及时进行缓存清理
- 避免存在内存泄露，比如尽量避免全局变量的使用、及时解除引用等
- 避免复杂/异常的递归调用，导致调用栈的溢出
