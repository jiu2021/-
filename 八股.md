# 八股

## http

### 状态码

1xx表示数据处理中间状态

204表示空body，206表示部分内容

301永久重定向，302暂时，304缓存重定向

403禁止访问，404找不到资源

501功能未开，503服务器忙

### 字段

host：主机地址

Content-Length：响应数据长度。解决粘包

Connection：

### get与post

GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。

POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。

### 缓存

- 强制缓存
  
  强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
  
  - `Cache-Control`， 是一个相对时间；
    
    优先级更高
  
  - `Expires`，是一个绝对时间；

- 协商缓存
  
  当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 `304`，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。
  
  第一种：请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现
  
  第二种：请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段
  
  **这时 Etag 的优先级更高**
  
  **协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**

### 版本

- 1.0短连接

- 1.1长连接解决性能问题
  
  管道传输解决了请求的队头堵塞，没有解决响应的队头堵塞、

以上不安全：

- 通信使用明文（不加密），内容可能会被窃听。
- 不验证通信方的身份，因此有可能遭遇伪装。
- 无法证明报文的完整性，所以有可能已遭篡改。

http2基于https

- 头部压缩
- 二进制格式
- 并发传输
- 服务器主动推送资源

仍存在队头堵塞问题：TCP堵塞

http3引入QUIC 

是一个在 UDP 之上的**伪** TCP + TLS + HTTP/2 的多路复用的协议。

### https

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

解决安全性的方法：

- 混合加密：建立通信前非对称，通信过程对称

- 摘要算法➕数字签名
  
  为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。

- 数字证书：数字证书信任链
  
  通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。

> - **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
> - **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

https基本流程：

SSL/TLS 协议基本流程：

四次握手（握手协议）

- 客户端向服务器索要并验证服务器的公钥。

- 双方协商生产「会话秘钥」。

- 双方采用「会话秘钥」进行加密通信。

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，保证完整性。

**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

**双向认证**方式，**防止中间人**，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。

### RPC和HTTP

- 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流，上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
- **RPC 本质上不算是协议，而是一种调用方式**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议**。
- 从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合**。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
- RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
- **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

### websoket

- TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。

## ping

- `127.0.0.1` 是**回环地址**。`localhost`是**域名**，但默认等于 `127.0.0.1`。
- `ping` 回环地址和 `ping` 本机地址，是一样的，走的是**lo0 "假网卡"**，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前**狠狠拐了个弯**， 将数据插入到一个**链表**后就**软中断**通知 **ksoftirqd** 来进行**收数据**的逻辑，**压根就不出网络**。所以断网了也能 `ping` 通回环地址。
- 如果服务器 `listen` 的是 `0.0.0.0`，那么此时用`127.0.0.1`和本机地址**都可以**访问到服务。

## cookie和token

http是无状态链接，我们有时候需要保存状态

都是由服务端颁发，客户端存储，每次请求时发送给服务端

对比：

- token可以抵抗csrf，cookie+session不行
- 分布式情况下的session和token，前者消耗服务器内存

总结：

- session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie
- cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。
- token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。
- jwt只是一个跨域认证的方案

## web安全

### CSRF

*CSRF* 全称叫做，跨站请求伪造(Cross—Site Request Forgery)，顾名思义，攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。对于服务器而言，判断请求对象是否是你本身的方法限于提供身份认证的cookie、秘钥等，无法去识别个体。

- 服务端进行同源检测
- 使用不存储在cookie中的token

### xss

- 反射型
  
  诱导用户提交恶意代码到服务端，并执行服务端返回的恶意代码，一般前后端一体的项目

- 存储型
  
  黑客直接向服务端提交恶意代码

- dom型
  
  诱导用户点击执行恶意脚本并发送请求

XSS（跨站脚本攻击，Cross-site scripting，简称并不是 CSS，因为 CSS是 层叠样式表）是一种常见的 web 安全问题。XSS 攻击手段是允许恶意web用户将代码植入到提供给其它用户使用的页面中。从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等

思路：

- 防止 HTML 中出现注入。
- 防止 JavaScript 执行时，执行恶意代码。

实际：

- 一切用户输入皆不可信，`在输出时进行验证`

- 将 `HTML 元素内容、属性以及 URL 请求参数、CSS 值进行编码`

- 当编码影响业务时，使用`白名单规则进行检测和过滤`

- 使用 W3C 提出的 `CSP (Content Security Policy，内容安全策略)`，定义域名白名单——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。

- 设置 `Cookie 的 HttpOnly` 属性
  
  如果HTTP响应头中包含HttpOnly标志，只要浏览器支持HttpOnly标志，客户端脚本就无法访问cookie。因此，即使存在跨站点脚本（XSS）缺陷，且用户意外访问利用此漏洞的链接，浏览器也不会向第三方透露cookie。

## TCP/IP

### 模型

- 应用层
  
   HTTP、FTP、Telnet、DNS、SMTP

- 传输层
  
  TCP、UDP，端到端

- 网络层
  
  IP，ARP解析出MAC地址

- 网络接口层

### 键入网址到网页显示

- 解析url

- 查询dns

- 委托协议栈封包

- TCP三次握手
  
  确保双方都收发能力都正常

- 交付IP层
  
  TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。

- 生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**

- 网卡出口
  
  网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程。

- 交换机

- 路由器

- 服务器协议栈解包

- 回应、应答

- TCP 四次挥手
  
  **TCP连接是全双工的，因此每个方向都必须单独进行关闭**
  
  首先为什么握手是三次，而挥手是四次：
  
  > 因为**握手的时候并没有数据传输**，所以服务端的 **SYN 和 ACK 报文可以一起发送**，但是**挥手的时候有数据在传输**，所以 **ACK 和 FIN  
  > 报文不能同时发送**，需要分两步，所以会比握手多一步。
  
  其次为什么三次挥手不可行：
  
  > 因为服务端在接收到FIN, 往往**不会立即返回FIN** ，必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。  
  > 如果是三次挥手会造成：  
  > 如果将服务端的两次挥手合为一次，等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候**长时间的延迟可能会导致客户端误以为FIN没有到达客户端**，从而让客户端不断的重发FIN。**所有只能第二次握手先发送ACK确认接收到了客户端的数据，等服务器发送完了数据，再发送FIN包进行第三次挥手。**
  
  延时2msl
  
  **一个**是为了让B能够按照**正常**步骤**进入CLOSED**状态，**二是**为了防止**已经失效**的请求连接报文出现在下次连接中。
  
  解释：
  
  1）、由于**客户端最后一个ACK可能会丢失**，这样B就无法正常进入CLOSED状态。于是B会重传请求释放的报文，而此时A如果已经关闭了，那就收不到B的重传请求，就会**导致B不能正常释放**。而如果A还在等待时间内，就会收到B的重传，然后进行应答，这样B就可以进入CLOSED状态了。
  
  2）、在这2MSL等待时间里面，本次连接的所有的报文都已经**从网络中消失**，从而不会出现在下次连接中。