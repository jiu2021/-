# 八股

## http

### 状态码

1xx表示数据处理中间状态

204表示空body，206表示部分内容

301（308不允许post到get）永久重定向，302（307不允许post到get）（303必须定为get）暂时重定向，304缓存重定向

403禁止访问，404找不到资源

501功能未开，503服务器忙

### 字段

host：主机地址

Content-Length：响应数据长度。解决粘包

Connection：

cache-control、content-encoding、content-type

请求头字段

Origin只有域名，referer包含域名+路径（请求来自哪个页面）；

地址栏直接输入url、刷新的时候referer都是null

csrf可以在服务端检查refer，过滤来自恶意网站的请求（但refer可以被篡改

### get与post

GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。

POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。

### 缓存

- 强制缓存
  
  强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
  
  - `Cache-Control`， 是一个**相对时间**，优先级更高
    
    - Private：只有客户端可以缓存
      Public：客户端、代理服务器也可以缓存
      no-store：不使用强、协商缓存
      no-cache：不使用强缓存
      s-maxage：代理服务器的缓存时间，单位为秒
      max-age：有效时间，单位为秒
  
  - `Expires`，是一个绝对时间；

- 协商缓存
  
  当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 `304`，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。
  
  第一种：请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段
  
  第二种：请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现
  
  **这时 Etag 的优先级更高**
  
  **协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**
  
  浏览器第一次加载资源，服务器返回200，浏览器将资源从服务器上下载下来，并把返回头即该请求的返回时间一并缓存；

- 下一次加载资源的时候，先比较当前时间和上次返回200的时间差，看是否超过`cache-control`的`max-age`，如果没有过期，直接命中强缓存，不发送请求直接从本地缓存中读取该文件，如果是`http1.1`以下版本，就看`Expires`字段进行判断是否过期；

- 服务器收到请求之后，优先根据`Etag`值判断该请求的资源是否被修改，`Etag`值一致则命中协商缓存，返回`304`，如果不一致，返回新的资源带上新的`Etag`并返回`200`；

- 如果服务器受到的请求没有`etag`值，就将`if-modified-Since`和被请求的文件的最后修改时间进行对比，一致则命中协商缓存，返回`304`，不一致就返回新的`last-modified`和文件并返回状态码`200`

<img title="" src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" alt="" width="508" data-align="center">

### 版本

- 1.0短连接

- 1.1长连接解决性能问题
  
  长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
  
  管道传输（默认未开启）解决了请求的队头堵塞，没有解决响应的队头堵塞

以上不安全：

- 通信使用明文（不加密），内容可能会被窃听。
- 不验证通信方的身份，因此有可能遭遇伪装。
- 无法证明报文的完整性，所以有可能已遭篡改。

http2基于https

- 头部压缩hpack
  
  在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**了。

- 二进制分帧：http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。

- 多路复用：并发传输 streamID
  
  针对不同的 HTTP 请求用独一无二的**Stream ID 来区分** ，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream

- 服务器主动推送资源
  
  客户端和服务器**双方都可以建立 Stream**， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。

仍存在队头堵塞问题：TCP堵塞（一旦发生丢包，堵塞后续http请求）

http3引入QUIC（Quick UDP Internet Connections）

- 无队头阻塞
  
  当某个流发生丢包时，**只会阻塞这个流**，其他流不会受到影响，因此不存在队头阻塞问题

- 更快的连接建立
  
   QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”

- 连接迁移
  
  QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等）

- 前向纠错、拥塞控制

是一个在 UDP 之上的**伪** TCP + TLS + HTTP/2 的多路复用的协议。

<img title="" src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png" alt="HTTP/1 ~ HTTP/3" width="528" data-align="center">

### https

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

解决安全性的方法：

- 混合加密：建立通信前非对称，通信过程对称，防窃听

- 摘要算法➕数字签名
  
  为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。

- 数字证书：数字证书信任链
  
  通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。

> - **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
> - **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

https基本流程：

SSL/TLS 协议基本流程：

**四次握手（握手协议）**

1. 客户端向服务端发起建立HTTPS请求。

2. 服务器向客户端发送数字证书。

3. 客户端验证数字证书，证书验证通过后客户端生成会话密钥（双向验证则此处客户端也会向服务器发送证书）。

4. 服务器生成会话密钥（双向验证此处服务端也会对客户端的证书验证）。

5. 客户端与服务端开始进行加密会话。

**TLS 记录协议**主要负责消息（HTTP 数据）的压缩，加密及数据的认证，保证完整性。

**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

**双向认证**方式，**防止中间人**，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。

### RPC和HTTP

- 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流，上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
- **RPC 本质上不算是协议，而是一种调用方式**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议**。
- 从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合**。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
- RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
- **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

### 长轮询

**长轮询就是（HTTP 请求将超时设置的很大）：** 客户端发起一个请求，服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断请求的数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则等待一定的时间后才返回。

长轮询的本质还是基于 HTTP 协议，它仍然是一个一问一答（请求 — 响应）的模式。而 WebSocket 在握手成功后，就是全双工的 TCP 通道，数据可以主动从服务端发送到客户端。

### websoket

- TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。

**心跳机制：**

而所谓的心跳包就是客户端定时发送简单的信息给服务器端告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息，如果服务端几分钟内没有收到客户端信息则视客户端断开。

### socket

是一种进程间通信技术，提供了编程接口，使开发者能够在应用层实现网络通信。

他是实现http协议的一种技术

## ping

- `127.0.0.1` 是**回环地址**。`localhost`是**域名**，但默认等于 `127.0.0.1`。
- `ping` 回环地址和 `ping` 本机地址，是一样的，走的是**lo0 "假网卡"**，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前**狠狠拐了个弯**， 将数据插入到一个**链表**后就**软中断**通知 **ksoftirqd** 来进行**收数据**的逻辑，**压根就不出网络**。所以断网了也能 `ping` 通回环地址。
- 如果服务器 `listen` 的是 `0.0.0.0`，那么此时用`127.0.0.1`和本机地址**都可以**访问到服务。

## web安全

### CSP

**内容安全策略**（[CSP](https://developer.mozilla.org/zh-CN/docs/Glossary/CSP)）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本（[XSS](https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting)）和数据注入攻击等。无论是数据盗取、网站内容污染还是恶意软件分发，这些攻击都是主要的手段。

为使 CSP 可用，你需要配置你的网络服务器返回 [`Content-Security-Policy`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy) HTTP 标头，并配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。比如一个可以上传文件和显示图片页面，应该允许图片来自任何地方，但限制表单的 action 属性只可以赋值为指定的端点。一个经过恰当设计的内容安全策略应该可以有效的保护页面免受跨站脚本攻击。

### 同源策略

**同源策略**是一个重要的安全策略，它用于限制一个[源](https://developer.mozilla.org/zh-CN/docs/Glossary/Origin)的文档或者它加载的脚本如何能与另一个源的资源进行交互。如果两个 URL 的[协议](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[端口 (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Port "Currently only available in English (US)")（如果有指定的话）和[主机](https://developer.mozilla.org/zh-CN/docs/Glossary/Host)都相同的话，则这两个 URL 是同源的。

可以使用 [CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS) 来允许跨源访问。CORS 是 [HTTP](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP) 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。

### CSRF

*CSRF* 全称叫做，跨站请求伪造(Cross—Site Request Forgery)，顾名思义，攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。对于服务器而言，判断请求对象是否是你本身的方法限于提供身份认证的cookie、秘钥等，无法去识别个体。

1. 验证来源：服务器端可以检查请求头中的Referer/Origin（不含路径）字段，来确保请求的来源是可信的。

2. 限制权限：在攻击者无法获得足够权限的情况下，CSRF攻击将变得更难。服务器应该分配最小权限给用户。

3. 双重认证（验证码）：如果对于某些涉及到资金、权限等重要信息的操作，应该为用户开设二次认证保护。

4. 在cookie中使用same-site属性：这样在跨站点请求时，cookie不会被发送。

### XSS

- 存储型
  
  黑客直接向服务端提交恶意代码，使服务端存储着恶意代码

- 反射型
  
  诱导用户提交恶意代码（拼接在url中）到服务端，并执行服务端返回的恶意代码（拼接在html中）

- dom型
  
  诱导用户点击执行恶意脚本并发送请求

XSS（跨站脚本攻击，Cross-site scripting，简称并不是 CSS，因为 CSS是 层叠样式表）是一种常见的 web 安全问题。XSS 攻击手段是允许恶意web用户将代码植入到提供给其它用户使用的页面中。从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。

1. 攻击者输入恶意代码；
2. 浏览器执行恶意代码；

思路：

- html转义，白名单机制（只允许少量合法输入），过滤特殊字符，可能会导致其他端乱码
  
  > 在一些前端框架中，都会有一份 `decodingMap`， 用于对用户输入所包含的特殊字符或标签进行编码或过滤

- 防止 JavaScript 执行恶意代码。
  
  设置 `Cookie 的 HttpOnly` 属性，如果HTTP响应头中包含HttpOnly标志，只要浏览器支持HttpOnly标志，客户端脚本就无法访问cookie。因此，即使存在跨站点脚本（XSS）缺陷，且用户意外访问利用此漏洞的链接，浏览器也不会向第三方透露cookie。

- 纯前端渲染可以避免存储型和反射型的攻击，但没法避免DOM型，攻击者可以通过onload事件、href中嵌入`javascript:...`进行攻击。

## TCP/IP

### 模型

- 应用层
  
   HTTP、FTP、Telnet、DNS、SMTP

- 传输层
  
  TCP、UDP，端到端

- 网络层
  
  IP，ARP解析出MAC地址

- 网络接口层

### 键入网址到网页显示

- 解析url

- 查询dns
  
  - 先查找本地缓存服务器
  
  - 递归服务器（本地域名服务器）询问根域名服务器，返回顶级域名服务器地址
  
  - 递归服务器询问顶级域名服务器

- 委托协议栈封包

- TCP三次握手
  
  确保双方都收发能力都正常

- 交付IP层
  
  TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。

- 生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**

- 网卡出口
  
  网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程。

- 交换机

- 路由器

- 服务器协议栈解包

- 回应、应答

- TCP 四次挥手
  
  **TCP连接是全双工的，因此每个方向都必须单独进行关闭**
  
  首先为什么握手是三次，而挥手是四次：
  
  > 因为**握手的时候并没有数据传输**，所以服务端的 **SYN 和 ACK 报文可以一起发送**，但是**挥手的时候有数据在传输**，所以 **ACK 和 FIN 报文不能同时发送**，需要分两步，所以会比握手多一步。
  
  其次为什么三次挥手不可行：
  
  > 因为服务端在接收到FIN, 往往**不会立即返回FIN** ，必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。  
  > 如果是三次挥手会造成：  
  > 如果将服务端的两次挥手合为一次，等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候**长时间的延迟可能会导致客户端误以为FIN没有到达客户端**，从而让客户端不断的重发FIN。**所有只能第二次握手先发送ACK确认接收到了客户端的数据，等服务器发送完了数据，再发送FIN包进行第三次挥手。**
  
  延时2msl
  
  **一个**是为了让B能够按照**正常**步骤**进入CLOSED**状态，**二是**为了防止**已经失效**的请求连接报文出现在下次连接中。
  
  解释：
  
  1）、由于**客户端最后一个ACK可能会丢失**，这样B就无法正常进入CLOSED状态。于是B会重传请求释放的报文，而此时A如果已经关闭了，那就收不到B的重传请求，就会**导致B不能正常释放**。而如果A还在等待时间内，就会收到B的重传，然后进行应答，这样B就可以进入CLOSED状态了。
  
  2）、在这2MSL等待时间里面，本次连接的所有的报文都已经**从网络中消失**，从而不会出现在下次连接中。

## TCP/UDP

![](https://uploadfiles.nowcoder.com/images/20230314/283207938_1678805553467/B6C31D01D41C9E1714958F9C56D01D8F)

1.基于连接与无连接；
2.对系统资源的要求（TCP较多，UDP少）；
3.UDP程序结构较简单；
4.流模式与数据报模式 ；
5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

### TCP

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于[字节流](https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E6%B5%81/3196772?fromModule=lemma_inlink)的[传输层](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536?fromModule=lemma_inlink)[通信协议](https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3351624?fromModule=lemma_inlink)，由[IETF](https://baike.baidu.com/item/IETF/2800318?fromModule=lemma_inlink)的[RFC](https://baike.baidu.com/item/RFC/2798645?fromModule=lemma_inlink) 793 [1]  定义。

在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。

- DDOS（拒绝服务）攻击的原理：首先攻击者向被攻击的服务器发送大量的虚假ip请求，被攻击者在收到请求后返回确认信息，等待攻击者进行确认，（此处需要拥有HTTP协议工作方式和tcp三次握手的基本知识）该过程需要TCP的三次握手，由于攻击者发送的请求信息是虚假的，所以服务器接收不到返回的确认信息，在一段时间内服务器会处与等待状态，而分配给这次请求的资源却被有被释放。当被攻击者等待一定的时间后，会因连接超时而断开，这时攻击者在次发送新的虚假信息请求，这样最终服务器资源被耗尽，直到瘫痪。

- DDOS(Distributed Denial Service)分布拒绝式攻击，它是在DOS基础上进行的大规模，大 范围的攻击模式，DOS只是单机和单机之间的攻击模式，而DDOS是利用一批受控制的僵尸主 机向一台服务器主机发起的攻击。

- 可靠传输
  
  **TCP通过序列号、检验和、确认应答信号、重发控制、连接管理、窗口控制、流量控制、拥塞控制实现可靠性。**

- 流量控制
  
  流量控制是为了控制发送方发送速率，保证接收方来得及接收。
  
  TCP 利用滑动窗口实现流量控制。
  
  接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

- 拥塞控制
  
  拥塞控制就是为了防止过多的数据注入网络中，这样可以使网络中的路由器或链路不会过载。
  
  慢开始--拥塞避免--快重传--快开始

### UDP

[Internet](https://baike.baidu.com/item/Internet%20/272794?fromModule=lemma_inlink) 协议集支持一个无连接的[传输协议](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/8048821?fromModule=lemma_inlink)，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为[应用程序](https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445?fromModule=lemma_inlink)提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。

- **UDP洪泛是一种拒绝服务攻击**，其中大量的用户数据报协议（UDP）数据包被发送到目标服务器，目的是压倒该设备的处理和响应能力。 防火墙保护目标服务器也可能因UDP泛滥而耗尽，从而导致对合法流量的拒绝服务。

## 进程

### 进程和线程

资源分配的最小单位和CPU调度的最小单位

### 死锁

- 互斥条件  
  临界资源是独占资源，进程应互斥且排他的使用这些资源。
- 占有和等待条件  
  进程在请求资源得不到满足而等待时，不释放已占有资源。
- 不剥夺条件  
  又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。
- 循环等待条件  
  又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。

## 浏览器渲染

![preview](https://segmentfault.com/img/remote/1460000012934765/view)

1.代码解析：浏览器向服务器请求到了 HTML 文档后便开始解析，产物是 DOM ，根据 CSS 生成 CSSOM（CSS对象模型）

2.对象合成：将 DOM 和 CSSOM 合并产生渲染树（render tree）

3.布局（layout）：有了渲染树，知道了所有节点的样式，便根据这些节点以及样式计算它们在浏览器中确切的大小和位置

4.绘制（paint）：即遍历render树，把节点绘制到浏览器上

简述：浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了渲染树（Render Tree） 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。

- html 一边解析一边显示，css 的加载和解析不会阻塞 html 文档的解析
- css 必须完全解析完毕才能进入生成渲染树环节，css的解析会阻塞js的执行，必须等到CSSOM生成后才能执行 js
- js 的执行会阻塞 html 文档的解析（加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是JavaScript可以修改DOM，所以必须把控制权让给它）

### script defer async

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/894d84e8a7e0497091a26e43e1a84237~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

- *defer* 和 *async* 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）
- 它俩的差别在于脚本下载完之后何时执行，显然 *defer* 是最接近我们对于应用脚本加载和执行的要求的
- 关于 *defer*，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用
- *async* 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行
- 仔细想想，*async* 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics

### 重绘和重排

重绘不改变dom结构，重排（回流）改变渲染树一部分

**浏览器优化重排**：由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列

**减少**：我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验：

- 使用css3硬件加速，可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘
- 减少DOM操作：插入时使用DOMfragment
- 对于那些复杂的动画，对其设置 `position: fixed/absolute`，尽可能地使元素脱离文档流，从而减少对其他元素的影响
- 如果想设定元素的样式，通过改变元素的 `class` 类名 (尽可能在 DOM 树的最里层)，避免逐次修改单个属性
- 操作会导致浏览器强制刷新队列，如：offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight

## 浏览器进程

### 1.Browser进程（主进程）

控制chrome的地址栏，书签栏，返回和前进按钮，同时还有浏览器的不可见部分，例如网络请求和文件访问

### 2. 第三方插件进程

每种插件一个进程，插件运行时才会创建

### 3. GPU进程

**仅此一个** ，用于3D绘制等，只有当该页面使用了硬件加速才会使用它

### 4. 浏览器渲染进程（浏览器内核）

负责界面渲染，脚本执行，事件处理等

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a8d76c9f5cf445bb752b61eed7a99a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" title="" alt="image.png" width="395">

1. GUI渲染线程
   
   - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
   
   - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。

2. JS引擎线程
   
   - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）JS引擎线程负责解析Javascript脚本，运行代码。
   
   - JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序，JS是单线程的。
   
   - PS：GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行;如果JS执行的时间过长，会导致页面渲染被阻塞。
   
   **引申：** webworker
   
   - 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
   - JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）
   
   > 有同源限制
   > 
   > 无法访问 DOM 节点
   > 
   > 运行在另一个上下文中，无法使用Window对象
   > 
   > Web Worker 的运行不会影响主线程，但与主线程交互时仍受到主线程单线程的瓶颈制约。换言之，如果 Worker 线程频繁与主线程进行交互，主线程由于需要处理交互，仍有可能使页面发生阻塞
   > 
   > 共享线程可以被多个浏览上下文（Browsing context）调用，但所有这些浏览上下文必须同源（相同的协议，主机和端口号）
   
   

3. 事件触发线程
   接受浏览器里面的操作事件响应。如在监听到鼠标、键盘等事件的时候， 如果有事件处理函数，就将对应的任务压入任务队列（添加到待处理队列的队尾），等待JS引擎的处理。
   事件触发线程管理着一个任务队列。

4. 定时触发器线程
   
   - setInternal与setTimeout所在线程
   
   - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
   
   - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

5. 异步http请求线程
   
   - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
   - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

## V8

> V8 是由 Google 开发的开源**JavaScript 引擎**，**是 JavaScript 虚拟机**的一种，模拟实际计算机各种功能来**实现代码的编译和执行**。我们可以简单地把 JavaScript 虚拟机理解成是一个翻译程序，将人类能够理解的 **编程语言 JavaScript**，翻译成机器能够理解的**机器语言。**

**「V8事件循环系统」**：事件循环系统和 JavaScript 中的难点**异步编程特性**紧密相关。JavaScript 是单线程的，JavaScript 代码都是在一个线程上执行，如果同一时间发送了多个 JavaScript 执行的请求，就需要排队，也就是进行异步编程。**而V8事件循环系统会调度这些排队任务，保证 JavaScript 代码被 V8 有序地执行。因此也可以说，事件循环系统就是 V8 的心脏，它驱动了 V8 的持续工作**。

**「垃圾回收机制」：JavaScript 也是一种自动垃圾回收的语言**。

- 简单数据类型内存保存在固定的栈空间中，可直接通过值进行访问
- 引用数据类型的值大小不固定，其引用地址保存在栈空间、引用所指向的值保存在堆空间中，需要通过引用进行访问



**标记清除**分为：标记阶段和清除阶段。

首先它会遍历堆内存上所有的对象，分别给它们打上标记，然后在代码执行过程结束之后，对所使用过的变量取消标记。在清除阶段再把具有标记的内存对象进行整体清除，从而释放内存空间。

**引用计数**是一种不常见的垃圾回收策略，其思路就是对每个值都记录其的引用次数。具体的：

- 当变量进行声明并赋值后，值的引用数为1。
- 当同一个值被赋值给另一个变量时，引用数+1
- 当保存该值引用的变量被其它值覆盖时，引用数-1
- 当该值的引用数为0时，表示无法再访问该值了，此时就可以放心地将其清除并回收内存。

## git

### fork、clone、branch

其三者区别如下：

- fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”
- clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓
- branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支

## token续签

- 每次请求都刷新
  
  - 并发请求有问题
  
  - 每次签名运算额外开销

- 两个token
  
  token（短） 未过期时，可以正常请求。
  
  token 过期了，refreshToken（长） 未过期，请求后端的刷新token接口对两个接口均进行刷新。
  
  token 和 refreshToken 均过期了，则用户必须重新登录。

## PWA应用

PWA（Progressive Web Apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。这些应用无处不在、功能丰富，使其具有与原生应用相同的用户体验优势。

- 客户端存储

- service worker

## MVC和MVVM

- 控制层。是应用程序中处理用户交互的部分，控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。

- 连接view和model的桥梁。因为，Model层中的数据往往是不能直接跟View中的控件一一对应上的，所以，需要再定义一个数据对象专门对应view上的控件。而[ViewModel](https://so.csdn.net/so/search?q=ViewModel&spm=1001.2101.3001.7020)的职责就是把model对象封装成可以显示和接受输入的界面数据对象。特点是具有双向绑定。

## 数据库

- 原子操作
  
  数据库的原子操作是指一个操作要么全部执行成功，要么全部不执行，不会出现只执行了一部分的情况，也不会出现多个操作并行执行的情况。在数据库中，原子操作主要是指事务，事务内的所有操作要么全部执行成功，要么全部取消回滚，保证数据的一致性和完整性。原子操作保证了数据库的事务性，同时也保证了数据的可靠性和安全性。

- sql与nosql
  
  SQL和NoSQL是不同类型的数据库，它们采用不同的数据存储方式和结构设计。SQL是关系型数据库，**使用表来存储数据，表之间可以使用主键进行关联**。NoSQL是非关系型数据库，**使用键值对、文档、图形或列族等非结构化方式来存储数据**。
  
  SQL和NoSQL的应用场景也不同。**SQL适用于需要快速处理复杂查询、关联和分析数据的应用程序**，例如财务系统、电子商务网站和货运管理系统等。而**NoSQL更适合处理大量数据和高并发访问的应用程序**，例如社交网络、日志管理和物联网等。
  
  另外，SQL在数据完整性和一致性方面表现更为优秀，可以保证在数据存储和查询过程中不会出现错误或数据丢失；而NoSQL则更注重数据的灵活性和扩展性，可以在不停机的情况下升级或扩展数据库。
  
  SQL和NoSQL的应用场景之所以不同，主要取决于他们的数据模型和数据结构。
  
  SQL使用关系型数据模型，数据被组织成表格形式的行和列，每一行代表一个实体，每一列代表实体的属性。SQL适合处理结构化数据，如金融、人事管理等领域。SQL具有严格的数据一致性和ACID特性，支持复杂查询，可保证数据完整性和可靠性。
  
  NoSQL使用非关系型数据模型，可以处理不确定性变化、半结构化、非结构化和流数据。NoSQL适用于大规模数据存储、高可扩展性和高速读写的应用场景，如社交媒体、物联网、云计算等领域。NoSQL没有固定的数据结构，可以存储各种类型的数据，如文本、图像、视频等多媒体数据。NoSQL具有链式数据一致性和BASE特性，支持分布式部署，数据可水平扩展，并能快速响应大量的并发请求。

## token

- 与jwt
  
  JWT是一种规范，而Token是一种实现方法，JWT提供了生成和验证Token的标准方式，在Web应用程序中，Token通常是基于JWT规范生成的。

- jwt构成
  
  JWT由三部分构成，分别是头部（Header）、载荷（Payload）和签名（Signature）、
  
  - 头部（Header）：JWT头部通常由两部分信息组成，分别是令牌类型（typ）和算法（alg）。
  
  - 载荷（Payload）：也称为声明（Claims），负责存储JWT所要传递的数据信息，比如用户ID、权限、过期时间等
  
  - 签名（Signature）：使用指定的算法将令牌类型、头部和载荷进行签名，生成签名。

- 解决的问题
  
  - 传统的Cookie使用需要在服务器端存储用户状态（session）信息，会导致高并发下服务器端的内存负担过大。JWT的无状态特性让服务器不再需要存储用户的状态信息。
  - session id的跨平台性较差，不同平台之间的会话状态不互通，而token通过在请求头中携带，可以跨平台使用。

- 防盗用
  
  签名中增加客户端属性、地理、⽹络位置信息
  
  存储在httponly的cookie中

## session id与cookie

Cookie是一种HTTP协议标准，用来在客户端存储会话信息。当用户访问一个网站并登录成功后，服务器会生成一个包含session ID的cookie，存储在客户端浏览器中，以后每次访问该网站，浏览器都会自动发送该cookie给服务器，以身份验证身份。

### 特点

- 存储有限：cookie的存储空间有限，浏览器一般限制每个网站的cookie数量和存储大小（几kb），超过限制后会自动删除旧的cookie。

- Cookie是绑定到域名的，每个网站之间的Cookie是不共享的。

- `Domain` 和 `Path` 标识定义了 Cookie 的*作用域*：即允许 Cookie 应该发送给哪些 URL。

### 限制访问

- 标记为 `Secure` 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。

- JavaScript [`Document.cookie`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie) API 无法访问带有 `HttpOnly` 属性的 cookie；此类 Cookie 仅作用于服务器。可以缓解跨站脚本攻击。

### 解决跨域

1. JSONP：通过script标签加载跨域脚本，将返回值封装在回调函数中，利用回调函数传递数据，而不是通过XHR，这种方法可以避免浏览器的同源策略。

2. CORS：使用XMLHttpRequest对象发送跨域请求，在请求头中设置Origin字段，服务器在响应头中设置Access-Control-Allow-Origin字段，并设置允许的域名，以允许跨域请求，同时可以设置Access-Control-Allow-Credentials: true允许带上Cookie。

3. 代理：搭建一个代理服务器，将所有请求转发到目标服务器，并将响应转发回客户端，这种方法可以避免浏览器的同源策略，但是需要额外的服务器支持，增加了网络请求的延迟。

## cdn原理

CDN全称是Content Delivery Network，即内容分发网络，也称为内容传送网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

通过DNS服务直接访问源站的请求响应过程。与其不同的是，**CDN将我们对源站的请求导向了距离用户较近的缓存节点**，而非源站。

在DNS解析域名时新增了一个`全局负载均衡系统（GSLB）`，GSLB的主要功能是根据用户的本地DNS的IP地址判断用户的位置，筛选出距离用户较近的`本地负载均衡系统（SLB）`，并将该SLB的IP地址作为结果返回给本地DNS。SLB主要负责判断`缓存服务器集群`中是否包含用户请求的资源数据，如果缓存服务器中存在请求的资源，则根据缓存服务器集群中节点的健康程度、负载量、连接数等因素筛选出最优的缓存节点，并将HTTP请求重定向到最优的缓存节点上。

## node

### koa详解

Koa是一个基于Node.js平台的Web框架。它使用异步编程，支持中间件。Koa通过一种被称为“洋葱圈模型”的方式来处理请求，这种模型的主要思想是在请求处理的整个生命周期中形成多个中间件，每个中间件都需要在请求处理结束之前完成自己的任务。这些中间件以一种特定的顺序串联起来，形成一条类似洋葱的环形，每个环上的中间件都会被依次调用，而请求的处理结果也将按照相反的顺序返回。

这种模型有两个关键的概念：上下文和next函数。

1. 上下文(Context)

上下文是一个JavaScript对象，代表了当前请求和响应的状态和属性。例如，它可以包含请求参数和响应头信息。在每个中间件函数的执行过程中，都会将上下文作为参数传递给该函数，中间件可以对上下文进行读写操作，最终将修改的信息传递给下一个中间件。

2. next函数

next函数是一个在中间件中调用的函数，它的作用是将控制权交给下一个中间件。每个中间件都需要调用next函数来将请求传递到下一个中间件。如果没有调用next函数，后续中间件将永远不会被执行，请求也不会得到响应。在下一个中间件完成处理后，它还可以将执行的结果传递回来，让前面的中间件进行处理。

原理总结

- 中间件函数的 next 不是直接调用的下一个中间件函数，而是调用的 fn 内部的 dispatch 函数，由它来调用下一个中间件函数并传递上下文对象（ctx）和自身（dispatch）。

- 中间件函数的执行顺序和注册顺序一致, 先 use 的中间件函数先执行。

- 一个中间件函数执行完毕，相应的 dispatch 函数将执行权转交给上一个中间件函数的 `await next()`执行该中间件函数 await 后续的代码。

### node模块查找

Nodejs项目模块路径解析是通过`require.resolve`方式实现的。

- require.resolve就是通过`Module._resolveFileName`方法实现的
- `Module._resolveFileName`核心流程是：
  - 判断该路径是否是内置模块
  - 不是，则通过`Module._resolveLookupPahts`方法，生成node_modules可能存在的路径，如果传入的路径是’/test/lerna/cli.js’，在每一级路径下加上`node_moduels`的路径数组
  - 通过`Module._findPath`查询模块的真实路径

`require.resolve.paths`实现原理是： 

- 如果是`/`（根路径）直接返回`['/node_modules']`
- 否则，将路径字符串从后往前遍历，查询到/时，拆分路径，在后面加上node_modules,并传入一个paths数组，直到查询不到/后返回paths数组

### PM2

progress manger

- PM2 是一个带有负载均衡功能的 Node 应用的进程管理器,利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单
- 当你要把你的独立代码利用全部的服务器上的所有 CPU，并保证进程永远都活着，0 秒的重载， PM2 是完美的。

**PM2的主要特性:**

- 内建负载均衡（使用Node cluster 集群模块）
- 后台运行
- 0秒停机重载，我理解大概意思是维护升级的时候不需要停机.？
- 具有Ubuntu和CentOS 的启动脚本
- 停止不稳定的进程（避免无限循环）
- 控制台检测
- 提供 HTTP API
- 远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )

### 多进程

Node.js 主线程是单线程的，如果我们使用 node app.js 方式运行，就启动了一个进程，只能在一个 CPU 中进行运算，无法应用服务器的多核 CPU。 为了解决这个问题，我们可以使用多进程分发策略，即**主进程接收所有请求，然后通过一定的负载均衡策略分发到不同的 Node.js 子进程中**。

每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。

Node 提供了 child_process 模块来创建子进程，方法有：

- **exec** - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。

- **spawn** - child_process.spawn 使用指定的命令行参数创建新进程。

- **fork** - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork('./son.js') 相当于 spawn('node', ['./son.js']) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。